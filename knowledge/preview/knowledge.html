<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:knowledge</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="1-linux">1. Linux</h1>
<h2 id="1-1-">1.1. 常用命令</h2>
<h3 id="1-1-1-echo">1.1.1. echo</h3>
<pre><code class="lang-sh">-n：newline。不输出换行，默认是会换行的
-e：escapes。解析转义字符和彩色输出，否则&quot;\n&quot;之类的特殊字符会直接按字面输出
echo &quot;`ll`&quot; # 加上&quot;&quot;按原命的输出格式进行输出

# 双引号&quot;&quot;和单引号&#39;&#39;的区别
echo &quot;test $a&quot; # 可以解析变量
echo &#39;test $a&#39; # $a会按字面输出

# 转义字符
\n：换行
\r：回车到行首进行覆盖输出
\t：制表符
\v：垂直制表符，换行并接着上一行末尾处输出
\f：同\v
\b：退格。当后面存在字符的情况下会删除\b之前的那个字符，可连续使用多个\b删除前面的多个字符
\c：忽略后面的字符，且前面的字符不换行输出
\\：输出\本身

# 彩色代码
\033[xx;yymstring\033[0m # xx和yy是任意表示前景色(字体颜色)或背景色的编码
前景色：30-黑色；31-红色；32-绿色；33-黄色；34-蓝色；35-紫色；36-浅蓝色；37-灰色
背景色：40-黑色；41-红色；42-绿色；44-黄色；44-蓝色；45-紫色；46-浅蓝色；47-灰色
其它：1-高亮；3-斜体；4-下划线；9-删除线
     0-复位(0可省略)；5-闪烁；7-反色(前背景互换)；8-隐身(字体颜色设为背景色)
</code></pre>
<h3 id="1-1-2-printf">1.1.2. printf</h3>
<pre><code class="lang-sh"># 基本语法：print format input
# printf默认不会换行

# 格式替换字符
%d：十进制整数
%f：浮点数
%s：字符串
%c：单个字符
%o：无符号八进制整数
%u：无符号十进制整数
%x：无符号十六进制整数，a-f表示10-15
%X：同上，A-F表示10-15
%%：%本身

%5s：指定字符串宽度为5，默认右对齐
%-5s：加上符号表示左对齐
%+d：当后面的数是整数时显示正号
%.3f：浮点数保留3位小数
%12.5d：表示占12位宽，整数长度为5，不足时前面补0
</code></pre>
<h3 id="1-1-3-grep">1.1.3. grep</h3>
<pre><code class="lang-sh"># 基本语法：grep [option] exp files
--color：高亮显示
-E：Extended。使用扩展正则表达式
-i：ignore。忽略大小写
-n：number。显示行号
-c：count。统计出现的行数(不是次数)
-B1：Before。显示匹配行的同时显示前面一行
-A1：After。显示匹配行的同时显示后面一行
-C1：Context。显示匹配行的同时显示前面和后面一行
-o：only-matching。只打印匹配到的关键字，若同一行有多个匹配，则会分别打印多行
-w：word。匹配整个单词
-v：invert。反向查找，即查找不存在匹配的行

# 只想知道是否有匹配，而不关心在哪匹配
grep -q exp file
echo $?
# 当有匹配时返回0，没有匹配时返回1
</code></pre>
<h3 id="1-1-4-sed">1.1.4. sed</h3>
<pre><code class="lang-sh"># 基本语法：sed [option] [-e script] [-f script_file] files
# 其中在命令中直接输入script时-e选项可以省略
# 默认会输出处理后的所有行，如果不想要默认输出则使用-n选项
a：在指定行后面追加一行
i：在指定行前面插入一行
d：删除指定行
c：替换指定行
s：替换指定字符串
p：打印指定行。一般与-n一起使用，否则除了打印指定行之外还会默认打印所有行

sed &#39;4a newline&#39; file # 在第4行后面添加一行，内容为newline
sed &#39;4a \ &#39; file # 添加只有一个空格的行
sed &#39;4a \\&#39; file # 添加一个空白行
sed &#39;3,5d&#39; file # 删除第3-5行
sed &#39;2,$c newlines&#39; file # 将第2行到最后一行替换为newlines一行
sed &#39;s/ev/op/g&#39; file # 将ev替换为op，如果最后面没有g，则只替换每一行的第一个匹配项
sed -n &#39;/^ev/p&#39; file # 打印以ev开头的行
sed -n &#39;/ev/{s/ev/op/g;p}&#39; file # 将ev替换为op并输出修改的行

-i：inplace。sed默认只输出修改后的内容而不会修改原文件，加上该选项后可修改原文件
sed -e &#39;2d&#39; -e &#39;5a newline&#39; file # 依次执行多条命令
</code></pre>
<h3 id="1-1-5-diff">1.1.5. diff</h3>
<pre><code class="lang-sh"># 比较两个命令输出的差异
diff &lt;(cmd1) &lt;(cmd2)
</code></pre>
<h3 id="1-1-6-seq">1.1.6. seq</h3>
<h2 id="1-2-vim">1.2. vim</h2>
<h2 id="1-3-shell">1.3. shell</h2>
<h3 id="1-3-1-">1.3.1. 变量</h3>
<pre><code class="lang-sh"># 全局变量
var=value # 创建变量
$var：使用变量
${var}str：当变量后面接其它字符时，需要用{}将变量名包裹
unset var # 撤销变量
unset -f func # 撤销函数

# 如果要定义局部变量，使用local关键字
local var=value

# 使用export关键字定义环境变量，环境变量可在子进程中使用
export var=value
export var # 或直接导出已有的普通变量为环境变量

# 只读变量，无法修改和撤销
readonly var=value
# 只读变量也分普通变量和环境变量
export readonly var=value

# 特殊变量
$0：当前脚本名称
$2：获得传入的第2个参数
${11}：如果参数位置超过一位数，需要将下标用大括号{}包裹
shift 2 # 剔除前2个参数，原来的第3个参数就变成了第1个参数
$?：保存着上一个命令的执行状态，范围为0-255，0表示正确执行，1、2、127为系统预留的状态码
$#：脚本中传入参数的个数
$@：当不加引号时，$@和$*等价，也与&quot;$@&quot;等价，都是以数组的形式传递参数列表
$*：当加上引号时，&quot;$*&quot;传递的是由所有参数组成的字符串
${@:2}：获取第2个参数后面的所有参数，@可以换成*
${@:2:3}：获取第2个参数后面的3个参数
$$：脚本运行的进程ID
$!：后台运行的最后一个进程的ID

# 使用declare声明变量
declare var=value
declare -i var=value # 指定变量为一个整型
declare -x var=value # 声明环境变量
declare -r var=value # 声明只读变量
declare -xr var=value # 声明一个只读环境变量
</code></pre>
<h3 id="1-3-2-">1.3.2. 字符串</h3>
<pre><code class="lang-sh"># 定义字符串
var=&#39;a$int\str&#39; # 单引号里的内容会原样输出，因此无法使用转义字符，也无法引用变量
var=&quot;\&quot;$arr\&quot;\n&quot; # 双引号中可以使用转义字符，也可以引用变量

# 获取字符串长度
${#var}
# 指定位置开始截取子串
${var:3}：从第3个字符开始截取到末尾
${var:0-3}：从倒数第3个字符开始截取到末尾
${var: -3}：同上，注意-3前面有个空格
# 指定位置开始截取指定长度子串
${var:3:5}：从第3个字符开始截取5个字符
${var:3:-2}：从第3个字符开始截取完之后，删除末尾的2个字符
# 删除指定字符及前面的所有字符
${var#*A}：删除从左往右第一个字符A及之前的所有字符
${var##*A}：删除从左往右最后一个字符A及之前的所有字符
# 删除指定字符及后面的所有字符
${var%A*}：删除从右往左第一个字符A及之后的所有字符
${var%%A*}：删除从右往左最后一个字符A及之后的所有字符
# 替换子串
${var/old/new}：将首次出现的old替换为new
${var//old/new}：将所有的old替换为new
${var/#old/new}：将行首的old替换为new
${var/%old/new}：将行尾的old替换为new
# 删除子串，和替换子串的语法类似，只是将new省略了(即替换为空串)
${var/str}：删除首次出现的子串str
# 大小写转换
${var^^}：将所有字母转换为大写
${var,,}：将所有字母转换为小写
# 字符串为空时的操作
${var:=value}：当var为空时返回value，并将var赋值为value
${var:-value}：当var为空时返回value，但不进行赋值操作
${var:+value}：当var不为空时返回value，也不进行赋值操作
${var:?value}：输出bash错误，其中value为错误提示信息
</code></pre>
<h3 id="1-3-3-">1.3.3. 数组</h3>
<pre><code class="lang-sh">var=(value1 value2 ...) # 定义数组
var[10]=ten # 可以单独为某个元素赋值，下标没有长度限制
${var[2]}：根据下标获取元素
${var[@]}：获取所有元素，只写var默认获取的是第1个元素
${var[*]}：同上
${#var[@]}：获取数组长度
${#var[*]}：同上

# 使用-A选项定义关联数组，即支持字符串作为下标，相当于是一个字典
declare -A var=([key1]=value1 [key2]=value2)
${!var[@]}：获取所有的key
${!var[*]}：同上
</code></pre>
<h3 id="1-3-4-">1.3.4. 算术运算</h3>
<pre><code class="lang-sh"># 使用let命令，支持++、--、+=、-=
let var=1+2：$var=3
# let只支持整数运算
let var=5/2 # $var=2，只保留结果的整数部分
let var=3.6*2 # 语法错误，不支持浮点数

# 使用expr命令，只支持整数运算。注意数字和运算符之间需要用空格隔开，且乘号*需要进行转义
expr 1 + 2 # 输出3
# 如果需要将运算结果赋值给变量，使用命令引用
var=`expr 5 \* 2` # $var=2

# 使用bc命令，支持浮点数运算
echo &#39;2.3+4&#39; | bc # 输出6.3
# 除法运算时需要指定精度，否则只会保留整数部分
echo &#39;scale=3;8/3&#39; | bc # 输出2.666
# 不使用管道，直接使用bc命令
bc &lt;&lt;&lt; &#39;2.3+4&#39;

# 使用算术运算语法，只支持整数运算，[]或(())里面引用变量不用加$
var=$[3+4] # $var=7
var=$((8/3)) # $var=2

# 直接声明变量为整型变量
declare -i var=1+3 # $var=4
</code></pre>
<h3 id="1-3-5-">1.3.5. 逻辑关系运算符</h3>
<pre><code class="lang-sh"># 非：!
# 与：-a或&amp;&amp;，&amp;&amp;有短路功能
# 或：-o或||，||有短路功能
# 除了是否有短路功能外，两者在语法上也有差别
[ $var1 -a $var2 ]
[ $var1 ] &amp;&amp; [ $var2 ]
[[ $var1 &amp;&amp; $var2 ]]
[[ $var1 ]] &amp;&amp; [[ $var2 ]]
# &amp;&amp;和||也可以用来控制多条命令的执行
cmd1 &amp;&amp; cmd2 # 当cmd1执行成功后执行cmd2
cmd1 || cmd2 # 当cmd1执行失败后执行cmd2

# 大于&gt;和小于&lt;，支持整数和字符串的比较。=和==都可以用来判等
[ 2 \&gt; 1 ] # 当使用单括号时需要进行转义
[[ &#39;a&#39; &lt; &#39;b&#39; ]]
# 当比较数字大小时也可以使用-gt和-lt，不支持字符串比较
[ 1 -lt 2 ]
[[ 2 -gt 1 ]]
# 一共6个整数关系运算符：-gt -ge -lt -le -eq -ne

# 匹配正则表达式
[[ $var =~ /exp/]]
</code></pre>
<h3 id="1-3-6-">1.3.6. 文件测试运算符</h3>
<pre><code class="lang-sh"># file是文件路径
[ -d $file ]：判断是否目录
[ -f $file ]：判断是否文件
[ -r $file ]：判断文件是否可读
[ -w $file ]：判断文件是否可写
[ -x $file ]：判断文件是否可执行
[ -e $file ]：判断文件是否存在
</code></pre>
<h3 id="1-3-7-">1.3.7. 控制流程</h3>
<pre><code class="lang-sh"># 条件控制语句
if condition
then
    command
elif condition
then
    command
else
    command
fi
# 在终端写成一行
if condition; then command; elif condition; then command; else command; fi

# for循环语句
for var in value1 value2
do
    command
done
# 在终端写成一行
for var in value1 value2; do command; done

# while循环语句
while condition
do
    command
done

# until循环
until condition
do
    command
done

# 无限循环
for (( ; ; ))
while true
while :
# 可以使用break和continue

# case语句
case var in
1|2|3)
    command
    ;; # break
*) # *表示默认选项
    command
    ;;
esac
</code></pre>
<h3 id="1-3-8-">1.3.8. 函数</h3>
<pre><code class="lang-sh">function func() { # function关键字和()都可以省略
    command; # 每行末尾需要加上分号;
    return x; # 返回0-255中的状态码，如果没有return语句则返回最后一条命令的状态码
}
func # 直接调用函数
func 1 2 3: # 带参数调用，函数内部可以使用$1之类的变量获取参数
</code></pre>
<h3 id="1-3-9-">1.3.9. 重定向</h3>
<pre><code class="lang-sh">cmd &gt; file # 输出重定向，覆盖原文件
cmd &gt;&gt; file # 输出重定向，往原文件末尾追加
cmd &lt; file # 输入重定向，将file的内容作为cmd的输入
# shell默认打开的3个文件：0-stdin; 1-stdout; 2-stderr
cmd 2&gt;file # 将stderr重定向
cmd &gt; file 2&gt;&amp;1 # 将输出和错误都重定向
cmd &lt; file1 &gt; file2 # 将输入和输出都重定向
# /dev/null是一个特殊的文件，写入其中的内容都会被丢弃
cmd &gt; /dev/null 2&gt;&amp;1 # 屏蔽输出和错误
</code></pre>
<h3 id="1-3-10-">1.3.10. 通配符</h3>
<pre><code class="lang-sh">?：匹配任意单个字符
*：任意数量的字符，包括空
[abc]：匹配[]中的任意字符
[a-z]：匹配范围内的任意字符
[a-9]：如果不是合法范围，则只会当成&quot;[a-9]&quot;这个字符串本身
[^abc]：^表示取反，即匹配[]中以外的任意字符
[!0-9]：!同^表示取反
{abc,123}：匹配abc或者123之一
ab{,c}：匹配ab或abc
{8..11}：8 9 10 11
{1..10..2}：步长为2输出 1 3 5 7 9
{008..11}：前面补0对齐 008 009 010 011
{e..a}：倒序输出 e d c b a
{a1..3c}：无法扩展，输出{a1..3c}本身

# 注意：*和?不能匹配路径分隔符/
ls */*.jpg
</code></pre>
<h3 id="1-3-11-">1.3.11. 注意事项</h3>
<pre><code class="lang-sh"># 反引号用于命令替换，等价于$()
echo `ll` # 将ll执行的结果打印出来。但结果不会换行
echo $(ll) # 推荐使用$()
echo &quot;$(ll)&quot; # 和ll直接执行的结果一样会换行

# shell脚本的运行
./run.sh # 开启子进程执行脚本，无法使用当前shell的普通变量
source ./run.sh # 不会产生子进程在当前shell中执行脚本，就可以使用当前shell的普通变量了
. ./run.sh # 第一个&#39;.&#39;的作用和source一样
# 在脚本文件中使用source或&quot;.&quot;相当于是导入了另一个文件，可以使用其中的变量

# 将多个命令组成成一个整体
(cmd1;cmd2)
{ cmd1;cmd2; } # 最后一个命令后面也要有&#39;;&#39;，且&#39;{}&#39;与命令之间需要用空格隔开
# ()中的命令会在子shell中执行，而{}会在当前shell中执行

# []与[[]]的区别，总的来说使用[[]]保险一些
# 1. 判断字符串是否为空
[ $var ]：判断变量是否为空
[[ $var ]]：也可以直接使用[[]]
[ -z &quot;$var&quot; ]：-z选项判断变量是否为空，这时变量需要加上引号，等价于test -n &quot;$var&quot;
[[ -n $var ]]：-n选项判断变量是否非空，使用[[]]时则不需要加引号
# 2. 逻辑运算符(前面的例子)
[ $var1 -a $var2 ]：-a和-o只能用在[]里
[ $var1 ] &amp;&amp; [ $var2 ]：&amp;&amp;和||使用[]时必须放在[]外面
[[ $var1 &amp;&amp; $var2 ]]：&amp;&amp;和||使用[[]]时既可放在里面也可放在外面
[[ $var1 ]] &amp;&amp; [[ $var2 ]]
# 3. 关系运算符
[[ $var =~ /exp/]]：正则表达式=~只能用[[]]
[ 2 \&gt; 1 ]：大小关系符&gt;&lt;使用[]时需要进行转义
[[ &#39;a&#39; &lt; &#39;b&#39; ]]

# [[]]和(())的区别(没完全理清，只记录一些场景)
# [[]]是增强[]，主要用于-z等条件测试、&lt;、&amp;&amp;等运算符
# (())是增强()，常用于算术运算，变量可以不使用$
if (($i&lt;5))
for ((i=0;i&lt;5;i++))
# [[]]与表达式直接要用空格分开，(())可以不用
# $((exp))和`expr exp`等价
</code></pre>
<h3 id="1-3-12-alias">1.3.12. 内置命令alias</h3>
<pre><code class="lang-sh">alias # 查看所有的别名
alias newcmd=&quot;cmd&quot; # 为cmd起个别名
unalias newcmd # 删除别名
unalias -a # 删除所有别名
</code></pre>
<h3 id="1-3-13-read">1.3.13. 内置命令read</h3>
<pre><code class="lang-sh">read var # 将读取的内容赋值给var
-p：prompt。提示信息
-t：timeout。设置超时时间，单位秒
-n：nchars。最大字符数量，当输入到指定数量的字符时直接结束输入
-s：silent。不显示输入，比如输入密码时
-e：使用命令补全功能
-a：array。以空格为分隔符输入数组
-r：raw。不将\作为转义字符，直接读取字符串本身的内容
</code></pre>
<h3 id="1-3-14-declare">1.3.14. 内置命令declare</h3>
<pre><code class="lang-sh">-：设置属性
+：取消设置的属性

i：整数
a：数组
A：关联数组，即key可以是字符串
r：只读变量
x：环境变量

declare -i var=1 # 定义整数
var=string # $var=0，因为var已经被定义为整数了
declare +i var # 取消var的整数属性
var=string # $var=string
</code></pre>
<h2 id="1-4-awk">1.4. awk</h2>
<pre><code class="lang-sh"># 基本语法：awk [option] &#39;pattern {action}&#39; files
# 默认的action是打印整行，即print $0

# 一个复杂一点的例子
awk -v name=&#39;hb&#39; -F; &#39;BEGIN{var1=val1;var2=val2}{print $1,$2}END{printf &quot;%s\n&quot;,&quot;end&quot;}&#39; files

# 打印奇偶行简洁写法
awk &#39;i=!i&#39; files # 奇数行
awk &#39;!(i=!i)&#39; fiels # 偶数行
</code></pre>
<h3 id="1-4-1-">1.4.1. 变量</h3>
<pre><code class="lang-sh"># 内置变量
$0：表示整行
$x：x是一个整数，表示第几列
NF：表示列数
$NF：表示最后一列

NR：表示当前行号，多个文件时行号会延续
FNR：多个文件时各个文件分别记录行号
FS：输入分隔符
OFS：输出分隔符
RS：输入换行符
ORS：输出换行符
FILENAME：当前文件名
ARGC：命令行参数的个数
ARGV：命令行参数数组，第一个参数就是awk本身，后面的参数是各个操作的文件名

# 自定义变量有两种方式，可以通过-v选项定义，也可以在action中直接定义和使用
awk &#39;BEGIN{var=4;print var}&#39;
# 数组也可以直接使用，awk中的数组其实是一个字典，它的键可以是字符串
awk &#39;BEGIN{arr[3]=8;print arr[3]}&#39;
# 对于没有定义的变量或数组元素，默认值是空字符串，即&quot;&quot;
key in arr：判断数组中是否存在某个元素
delete arr[key]：删除数组中的元素
delete arr：删除整个数组
# 注意用for遍历数组时，遍历的是key而不是value，且是无序的

# 对字符串变量进行加法运算时，变量会被当做0
awk &#39;BEGIN{var=&quot;test&quot;;print var+1}&#39;
</code></pre>
<h3 id="1-4-2-option">1.4.2. option</h3>
<pre><code class="lang-sh"># 分隔符分输入分隔符和输出分隔符，默认都是空格
-F;：指定分号&#39;;&#39;为输入分隔符
-v FS=&#39;;&#39;：通过内置变量指定输入分隔符
-v OFS=&#39;#&#39;：指定输出分隔符为&#39;#&#39;
-v VAR=val：自定义变量
</code></pre>
<h3 id="1-4-3-pattern">1.4.3. pattern</h3>
<pre><code class="lang-sh"># 当pattern满足条件时，后面的action才会执行
BEGIN：指定在处理文本之前执行的操作
END：指定在处理文本之后执行的操作
空模式：任何一行都满足条件

# 关系表达式，如== != &lt; &lt;= &gt; &gt;=
NR&gt;=5 &amp;&amp; NR&lt;=10 # 输出第5行到第10行

# 正则表达式
~：表示匹配正则表达式时为真
!~：表示不匹配正则表达式时为真
# 直接使用正则表达式而不说明哪个变量需要满足条件时，默认为整行，即$0~/exp/
# 当使用匹配次数的正则表达式时，需要加上--posix或--re-interval选项
awk --posix &#39;/a{2,4}bc/{print}&#39; files

# 匹配两个正则表达式之间的行
&#39;/exp1/,/exp2/&#39; # 匹配exp1第一次出现的行与exp2第一次出现的行之间的所有行
</code></pre>
<h3 id="1-4-4-action">1.4.4. action</h3>
<pre><code class="lang-sh">print：打印并换行。打印多个数据时如果用逗号&#39;,&#39;连接，则输出数据会以输出分隔符分隔，否则多个数据会紧连
printf：用法和printf命令基本一样，只不过格式与字符串之间要用逗号&#39;,&#39;隔开

# 条件控制语句，和c++的语法一样
if () {} else if () {} else {}
condition?action1:action2 # 三目运算符
# 循环语句
for (i=0;i&lt;10;++i) {}
for (key in arr) {}
while () {}
do {} while ()
# 循环语句中同样有break和continue语句

next：结束当前行，继续下一行，类似于循环语句中的continue
exit：直接跳到END模式执行的动作，如果没有END模式则直接结束awk
</code></pre>
<h3 id="1-4-5-">1.4.5. 内置函数</h3>
<pre><code class="lang-sh"># 算术函数
srand()：生成随机数种子
rand()：生成0-1之间的随机数
int()：转化为整数

# 字符串函数
length($0)：返回字符串长度，不指定参数时默认为$0
index($0,&#39;str&#39;)：查找子串出现的位置，不存在时返回0
gsub(&#39;old&#39;,&#39;new&#39;,$0)：字符串替换，第3个参数不指定时默认为$0。支持正则表达式
sub(&#39;old&#39;,&#39;new&#39;,$0)：只替换第一个匹配项
split(str,arr,sep)：将str按sep切割，存到arr数组中，下标从1开始。返回的是数组的长度

# 其它函数
asort(arr)：将数组元素升序排列，但排序后的数组下标会从1开始重置。返回数组的长度
asort(arr,res)：将排序后的结果存到res，不改变原来的数组
asorti(arr,res)：将数组的key排序后存到res中。返回数组的长度
</code></pre>
<h1 id="2-">2. 通用知识</h1>
<h2 id="2-1-">2.1. 正则表达式</h2>
<h3 id="2-1-1-">2.1.1. 普通字符</h3>
<pre><code class="lang-sh">[abc]：匹配abc里的任意字符
[^abc]：匹配非abc里的任意字符
[a-z]：匹配ASCII码在a和z之间的任意字符
[!-a]：匹配ASCII码小于等于a的任意字符
[a-~]：匹配ASCII码大于等于a的任意字符
.：匹配除换行符之外的任意字符，等价于[^\r\n]
ab|12：匹配ab或12
\d：匹配数字，等价于[0-9]
\D：匹配非数字
\w：匹配数字、字母、下划线，等价于[0-9A-Za-z_]
\W：匹配非数字、字母、下划线
</code></pre>
<h3 id="2-1-2-">2.1.2. 非打印字符</h3>
<pre><code class="lang-sh">\r：匹配回车符
\n：匹配换行符
\t：匹配制表符
\v：匹配垂直制表符
\f：匹配换页符
\s：匹配所有空白字符，等价于[ \r\n\t\v\f]
\S：匹配所有非空白字符，等价于[^ \r\n\t\v\f]
</code></pre>
<h3 id="2-1-3-">2.1.3. 定界符</h3>
<pre><code class="lang-sh">^：锚定行首，即匹配以exp开头的行
$：锚定行尾
\&lt;：锚定词首，即匹配以exp开头的单词
\&gt;：锚定词尾
\b：既可锚定词首又可锚定词尾，即可替换\&lt;或\&gt;
\B：匹配非单词边界，即匹配不以exp开头但包含exp的单词
</code></pre>
<h3 id="2-1-4-">2.1.4. 限定符</h3>
<pre><code class="lang-sh">*：匹配任意次数
+：匹配1次或多次
# *和+默认匹配是贪婪的，即它会尽可能多地去匹配，在其后面加上?可以实现非贪婪匹配
# 比如对于字符串&lt;h1&gt; title &lt;/h1&gt;，正则表达式/&lt;.*&gt;/会匹配整个字符串，而/&lt;.*?&gt;/则只会匹配到&lt;h1&gt;

?：匹配0次或1次
{n}：匹配n次
{n,}：匹配至少n次
{n,m}：匹配至少n次、至多m次
</code></pre>
<h3 id="2-1-5-">2.1.5. 分组与引用</h3>
<pre><code class="lang-sh">(exp)：匹配exp并缓存，可用\x(x是一个数字)代替第x个分组匹配的结果
# /\b([a-z]+) \1\b/可以用来匹配两个相同相邻的单词，\1表示前面匹配到的那个单词

(?:exp)：匹配exp但不缓存
exp2(?=exp1)：查找exp1前面的exp2，同样exp1不会被缓存
(?&lt;=exp1)exp2：查找exp1后面的exp2
exp2(?!exp1)：查找后面不是exp1的exp2
(?&lt;!exp1)exp2：查找前面不是exp1的exp2
</code></pre>
<h3 id="2-1-6-">2.1.6. 修饰符</h3>
<pre><code class="lang-sh">/abc/i：不区分大小写
/abc/g：查找所有的匹配项
/^abc/m：多行匹配，使得^和$匹配每一行的开头和结尾，而不是匹配整个字符串的
/ab./s：使得.可以匹配换行符，默认情况下.是匹配换行符以外的任意字符
</code></pre>
<h3 id="2-1-7-">2.1.7. 内置字符簇</h3>
<pre><code class="lang-sh">[[:digit:]]：数字
[[:alpha:]]：字母
[[:alnum:]]：数字和字母
[[:upper:]]：大写字母
[[:lower:]]：小写字母
[[:space:]]：空白字符
[[:punct:]]：任何标点符号
[[:xdigit:]]：16进制数字，等价于[0-9A-Fa-f]
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>